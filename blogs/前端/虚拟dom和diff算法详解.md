---
title: 深入浅出：Vue 与 React 的虚拟 DOM 和 Diff 算法全解析（含 Vue 3 优化）
date: 2025/05/03
tags:
 - 框架原理
---

在现代前端框架的浪潮中，Vue.js 和 React.js 无疑是两颗璀璨的明星。它们都以高效的性能和声明式的编程范式赢得了广大开发者的青睐。而在这背后，虚拟 DOM (Virtual DOM, VDOM) 和 Diff (Difference) 算法扮演着至关重要的角色。本文将带你由浅入深地探索它们的奥秘，并对比两者之间的差异，最后重点解析 Vue 3 在 Diff 算法上所做的革命性优化。

## 一、什么是虚拟 DOM (Virtual DOM)？

在理解 Diff 算法之前，我们首先需要明白什么是虚拟 DOM。

### 1. DOM 的“昂贵”代价

我们知道，Web 页面的内容、结构和样式都是通过文档对象模型 (Document Object Model, DOM) 来表示和操作的。当页面内容发生变化时，我们需要更新 DOM 以反映这些变化。然而，直接操作真实 DOM 的开销是相当大的：

* **性能瓶颈**：频繁地、小范围地修改真实 DOM 会导致浏览器进行大量的重绘 (Repaint) 和回流 (Reflow)，这些操作非常消耗性能，可能导致页面卡顿。
* **状态管理复杂**：手动管理 DOM 更新逻辑复杂且容易出错，尤其是在大型应用中。

### 2. 虚拟 DOM 的诞生

为了解决上述问题，虚拟 DOM 的概念应运而生。

* **定义**：虚拟 DOM 本质上是一个**JavaScript 对象**，它是对真实 DOM 结构的一个轻量级、内存中的抽象表示。它描述了真实 DOM 应该是什么样子。
* **工作流程**：
    1.  当应用状态发生改变时，框架会根据新的状态生成一个新的虚拟 DOM 树。
    2.  框架会将这个新的虚拟 DOM 树与上一次渲染时生成的旧虚拟 DOM 树进行比较（这就是 Diff 算法的用武之地）。
    3.  通过比较，找出两棵树之间的最小差异。
    4.  最后，框架会将这些差异高效地批量应用到真实 DOM 上，从而最大限度地减少直接操作真实 DOM 的次数和范围。

可以把虚拟 DOM 想象成建筑的**设计蓝图**。当需要修改建筑时，我们不是直接去砸墙拆瓦，而是先在蓝图上规划好修改方案，计算出最经济、影响最小的改动，然后再派施工队一次性精准施工。

## 二、什么是 Diff 算法？

Diff 算法是虚拟 DOM 技术的核心，它的主要任务是**比较两个虚拟 DOM 树之间的差异**，并找出一种最高效的方式来更新真实 DOM。

### 1. 传统 Diff 的挑战

完整地比较两棵任意树的差异，其算法复杂度通常是 $O(n^3)$，其中 $n$ 是树中节点的数量。对于复杂的前端应用来说，这个开销是无法接受的。

### 2. 现代框架的启发式策略

Vue 和 React 等现代框架的 Diff 算法都采用了一些**启发式策略 (Heuristics)**，将比较的复杂度优化到了 $O(n)$。这些策略基于一些实际开发中的常见情况：

* **策略一：只比较同层级的节点 (Tree Diffing)**：
    * 框架会逐层比较新旧两棵虚拟 DOM 树。如果一个节点在某一层消失了，那么它及其所有子节点都会被完全移除。如果一个节点在某一层新增了，那么它及其所有子节点都会被全新创建。
    * 这意味着跨层级的节点移动（比如将一个父节点的子节点移动到另一个父节点下）会被视为旧节点的删除和新节点的创建，而不是移动。虽然这可能不是理论上的最优解，但在实际应用中，跨层级移动节点的情况相对较少，这种简化大大提高了比较效率。

* **策略二：组件类型的比较 (Component Diffing)**：
    * 如果两个节点代表的是不同类型的组件，那么 React/Vue 会直接销毁旧组件，创建并挂载新组件。它们不会尝试去复用或比较不同类型组件的内部结构。
    * 如果两个节点代表的是相同类型的组件，框架会保留组件实例，仅更新其属性 (props)，并递归地对其子节点进行 Diff。

* **策略三：元素类型的比较 (Element Diffing)**：
    * 如果两个节点代表的是相同类型的 HTML 元素 (如都是 `<div>` 或都是 `<p>`)，框架会保留该元素，并比较其属性 (attributes) 的差异，只更新发生变化的属性。
    * 然后，框架会递归地处理该元素的子节点。

* **策略四：列表的 `key` 属性 (Keyed Fragments/Lists)**：
    * 当处理一个节点列表（例如 `<ul>` 中的多个 `<li>`）时，如果没有提供 `key`，或者 `key` 值相同但顺序发生变化，框架可能需要进行大量的 DOM 移动或重建操作。
    * 通过为列表中的每个子节点提供一个**唯一的、稳定的 `key` 属性**，Diff 算法可以更智能地识别节点的移动、删除和新增。例如，如果一个带 `key` 的节点从列表头部移动到了尾部，Diff 算法能够识别出这是一个“移动”操作，而不是“删除旧节点并在尾部创建新节点”，从而实现更高效的 DOM 更新，并能保持组件的内部状态（如输入框的内容）。

## 三、React 的虚拟 DOM 和 Diff 算法

### 1. VDOM 表现形式

在 React 中，虚拟 DOM 节点通常被称为 **React Elements**。它们是描述 UI 组件或 HTML 标签的普通 JavaScript 对象。`JSX` 最终会被编译成 `React.createElement()` 调用，这些调用返回的就是 React Elements。

```javascript
// JSX
const element = <h1 className="greeting">Hello, world</h1>;

// 等价的 React.createElement() 调用
const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Hello, world'
);

// element 对象的结构（简化版）
{
  type: 'h1',
  props: {
    className: 'greeting',
    children: 'Hello, world'
  },
  // ...其他属性如 key, ref
}
```

### 2. Diff 策略特点

React 的 Diff 算法遵循上述提到的启发式策略：

* **Tree Diffing**：逐层比较。
* **Component Diffing**：
    * 不同类型的组件：销毁旧的，创建新的。
    * 相同类型的组件：更新 props，递归 diff 子节点。开发者可以通过 `shouldComponentUpdate` (类组件) 或 `React.memo` (函数组件配合 `areEqual` 函数) 来手动控制组件是否需要重新渲染，从而进行性能优化。
* **Element Diffing**：
    * 相同类型的 HTML 元素：保留 DOM 节点，仅更新变化的属性。
    * 不同类型的 HTML 元素：移除旧的，创建新的。
* **Keys for Lists**：当比较一组子节点时，React 会同时遍历新旧两组子节点。
    * **无 `key` 或 `key` 不足以区分**：它会按顺序进行比较，如果发现不一致，则销毁后续所有旧节点，并创建所有新节点。这在列表项顺序改变或中间插入/删除项时效率较低。
    * **有 `key`**：React 使用 `key` 来匹配新旧列表中的元素。
        1.  首先，它会尝试匹配 `key` 相同的节点。
        2.  对于未匹配上的新 `key`，创建新节点。
        3.  对于未匹配上的旧 `key`，删除旧节点。
        4.  对于 `key` 相同但位置可能改变的节点，进行移动操作。

React 的 Diff 过程可以概括为：当组件状态或 props 改变时，`render` 方法会返回一个新的 React Element 树。React 会将这棵新树与旧树进行比较，计算出需要对真实 DOM 进行的最小更新。

## 四、Vue 的虚拟 DOM 和 Diff 算法

Vue 的虚拟 DOM 和 Diff 算法在核心思想上与 React 类似，但也存在一些重要的差异和优化，尤其是在 Vue 3 中。

### 1. VDOM 表现形式

在 Vue 中，虚拟 DOM 节点被称为 **VNode**。模板 (template) 会被 Vue 的编译器编译成渲染函数 (render function)，而渲染函数执行后会返回一个 VNode 树。

```javascript
// Template
// <div id="app" :class="myClass">Hello {{ name }}</div>

// 渲染函数（简化示意）
function render() {
  return h('div', { id: 'app', class: this.myClass }, [
    'Hello ',
    this.name // 文本节点也会是 VNode
  ]);
}

// VNode 结构（简化版）
{
  tag: 'div', // 标签名
  data: { // 属性、事件等
    attrs: { id: 'app' },
    class: 'some-class'
  },
  children: [ // 子 VNode
    { tag: undefined, text: 'Hello ' },
    { tag: undefined, text: 'Vue' } // 假设 this.name 是 'Vue'
  ],
  // ...其他属性如 key, elm (对应的真实 DOM 元素)
}
```

### 2. Vue 2 的 Diff 策略特点

Vue 2 的 Diff 算法同样基于上述启发式策略，但在列表 Diff (子节点 Diff) 方面有一个著名的优化：**双端比较 (Double-ended Comparison / Two-ended Diffing)**。

当比较一个列表的新旧 VNode 子节点时 (比如 `v-for` 生成的列表)，Vue 2 的 Diff 算法会同时维护四个指针：

* `oldStartIndex`：指向旧 VNode 列表的开始位置
* `oldEndIndex`：指向旧 VNode 列表的结束位置
* `newStartIndex`：指向新 VNode 列表的开始位置
* `newEndIndex`：指向新 VNode 列表的结束位置

它会进行多轮比较，尝试以最高效的方式匹配节点：

1.  **旧首 vs 新首** (`oldStartVnode` vs `newStartVnode`)：如果相同，则 patch 它们，两个指针都后移。
2.  **旧尾 vs 新尾** (`oldEndVnode` vs `newEndVnode`)：如果相同，则 patch 它们，两个指针都前移。
3.  **旧首 vs 新尾** (`oldStartVnode` vs `newEndVnode`)：如果相同，则 patch 它们，并将旧首对应的真实 DOM 节点移动到旧尾之后，旧首指针后移，新尾指针前移。
4.  **旧尾 vs 新首** (`oldEndVnode` vs `newStartVnode`)：如果相同，则 patch 它们，并将旧尾对应的真实 DOM 节点移动到旧首之前，旧尾指针前移，新首指针后移。

如果以上四种比较都不匹配：

* 会尝试使用 `key` 来查找匹配。如果新首节点 (`newStartVnode`) 的 `key` 在旧列表中存在，则进行 patch 和移动。
* 如果找不到 `key` (或者节点没有 `key`)，则将 `newStartVnode` 视为新节点并创建。

这个双端比较策略能够有效地处理列表两端的变化、列表反转等情况，比 React 单纯从头到尾的比较在某些场景下更优。

## 五、Vue 与 React Diff 算法的主要差异总结

1.  **编译优化程度**：
    * **Vue**：Vue 的模板在编译阶段可以进行更多的静态分析。编译器可以标记出哪些部分是静态的（永远不会改变），哪些部分是动态的。这为后续的 Diff 过程提供了重要信息，允许 Vue 跳过对静态内容的 Diff。Vue 3 在这方面做得更为极致。
    * **React**：React 主要依赖 JSX，其灵活性更高，但编译时能做的静态分析相对较少。优化通常依赖开发者手动使用 `React.memo`、`useCallback`、`useMemo` 和 `shouldComponentUpdate`。

2.  **列表 Diff 策略 (Vue 2 vs React)**：
    * **Vue 2**：采用双端比较算法，对列表的头尾移动、反转等场景有较好的优化。
    * **React**：主要从头开始匹配，依赖 `key` 进行高效的节点复用和移动。

3.  **更新粒度与响应式系统**：
    * **Vue**：Vue 的响应式系统能够精确追踪到是哪个数据发生了变化。当数据变化时，它能够“通知”依赖该数据的组件或 VNode 进行更新。这使得 Vue 在某些情况下可以做到更细粒度的更新，甚至可能跳过整个 Diff 过程，直接更新某个动态绑定。
    * **React**：React 的更新通常是从根组件或调用了 `setState`/`useState` 的组件开始，自顶向下进行 Diff。虽然 React 也有一些优化（如 Fiber 架构可以中断和恢复渲染），但其“拉”数据的特性决定了它需要 Diff 子树来确定变化。

## 六、Vue 3 Diff 算法的革命性优化

Vue 3 在 Diff 算法方面引入了多项重要的优化，这些优化主要得益于其编译器在编译模板时收集到的更多信息。其核心目标是**最大限度地减少运行时 Diff 的工作量**。

### 1. 静态树提升 (Static Tree Hoisting)

* **概念**：对于模板中完全静态的部分（即不包含任何动态绑定、没有 `v-if`/`v-for` 等指令的纯 HTML 结构和内容），Vue 3 编译器会将其“提升”出 `render` 函数。这意味着这些静态内容的 VNode 在组件初始化时只创建一次，后续的重新渲染会直接复用这些静态 VNode，完全跳过对它们的 Diff。
* **好处**：减少了 VNode 创建的开销，并显著减少了 Diff 的范围。

```html
<div>
  <h1>我是静态标题</h1> <p>我也是静态段落</p> <div>{{ dynamicContent }}</div> </div>
```

### 2. Patch Flags (补丁标记)

这是 Vue 3 Diff 算法中最具创新性的优化之一。

* **概念**：在编译阶段，Vue 3 的编译器会分析模板中的动态绑定。对于动态节点 (包含动态属性、动态文本内容等的 VNode)，编译器会根据其可能发生变化的类型给它打上一个或多个“补丁标记 (Patch Flag)”。这个标记是一个数字，表示该节点需要进行哪些类型的更新检查。
* **示例 Patch Flags**：
    * `TEXT = 1`：表示该节点只有文本内容是动态的。Diff 时只需比较文本内容。
    * `CLASS = 1 << 1` (二进制 `10`): 表示只有 `class` 绑定是动态的。
    * `STYLE = 1 << 2` (二进制 `100`): 表示只有 `style` 绑定是动态的。
    * `PROPS = 1 << 3` (二进制 `1000`): 表示有非 `class`/`style` 的动态属性。
    * `FULL_PROPS = 1 << 4`: 表示有动态 `key`，或者 `props` 的数量可能改变，需要完整的 `props` Diff。
    * `HYDRATE_EVENTS = 1 << 5`: 节点带有仅在 hydration 阶段需要处理的事件监听器。
    * `NEED_PATCH = 1 << 9`: 表示该节点是一个带有 `ref` 或者 `v-on` 指令的组件，需要进行 patch。
    * `KEYED_FRAGMENT = 1 << 7`, `UNKEYED_FRAGMENT = 1 << 8`: 表示片段的子节点是否有 key。
    * `HOISTED = -1`: 表示这是一个静态提升的节点，不需要 patch。
    * `BAIL = -2`: 表示一个 diff过程应该退出优化模式。

* **工作方式**：在运行时进行 Diff 时，Vue 3 会检查 VNode 上的 `patchFlag`。
    * 如果一个节点没有 `patchFlag` 或者 `patchFlag` 为 `HOISTED`，则跳过它的 Diff。
    * 如果节点有 `patchFlag`，例如 `TEXT`，那么 Diff 算法就只比较新旧 VNode 的文本内容，而完全忽略其属性、子节点等的比较。如果 `patchFlag` 是 `CLASS`，就只比较 `class`。
* **好处**：极大地缩小了 Diff 的范围。不再需要对整个 VNode 的所有属性和子节点进行完整比较，而是“按需 Diff”，只 Diff 真正可能变化的部分。

### 3. Block Tree (块级树) 与动态节点追踪

* **概念**：Vue 3 编译器会将模板分割成“块 (Block)”。一个块通常是包含动态内容的 VNode 节点，或者是一个带有 `v-if` / `v-for` 指令的节点。在每个块内部，编译器会收集所有动态的后代节点（即那些带有 `patchFlag` 的节点），并将它们存储在一个扁平化的数组中。
* **工作方式**：当一个组件更新时，Vue 3 不再需要递归地遍历整个 VNode 树。它只需要遍历这个组件内所有 Block 中的动态节点列表。由于这些动态节点已经被预先收集并标记了 `patchFlag`，Diff 过程变得非常高效。
* **好处**：
    * **更新性能与模板大小解耦**：组件的更新性能不再与模板的整体大小成正比，而是与模板中动态内容的数量成正比。即使模板非常庞大，只要动态内容少，更新依然很快。
    * **跳过静态结构**：整个静态的树结构分支在 Diff 过程中被完全忽略。

### 4. 缓存事件处理函数 (Cache Handlers)

* **概念**：在 Vue 2 中，如果模板中使用了内联的事件处理函数（例如 `@click="() => count++"`），每次父组件重新渲染时，即使事件处理函数的逻辑没有改变，也会生成一个新的函数实例。这会导致子组件因为接收到新的 `props` (事件处理函数也是 `props`) 而不必要地重新渲染。
* **Vue 3 优化**：编译器可以检测到这种情况，并将内联的事件处理函数缓存起来。除非依赖的数据发生变化，否则会复用相同的函数实例。
* **好处**：减少了不必要的子组件更新，提高了性能。

### Vue 3 Diff 总结

Vue 3 通过编译时的深度优化（静态提升、补丁标记、块级树），将大量 Diff 工作提前到编译阶段完成，使得运行时的 Diff 算法变得极其轻量和高效。它不再是 Vue 2 那样的“完整 Diff”配合一些启发式策略，而是变成了一种“靶向精确打击”的更新模式。对于列表的 Diff，Vue 3 仍然使用了类似 Vue 2 双端比较的思想，但结合了 `patchFlag`，可以更快速地处理。例如，如果一个列表中的所有子项都是静态的，只是顺序可能变化（通过 `key`），那么 Diff 就会非常快。

## 七、我们何时需要“关心”Diff 算法？

对于大部分日常开发而言，我们其实**不太需要直接关心 Diff 算法的内部细节**。Vue 和 React 已经为我们处理了绝大部分的性能优化工作。我们更应该关注的是：

1.  **正确使用 `key`**：在渲染列表时，务必为每个列表项提供唯一的、稳定的 `key`。这是保证列表更新性能和状态保持的关键。
2.  **避免不必要的组件渲染**：
    * 在 React 中，合理使用 `React.memo`、`useCallback`、`useMemo`，以及在类组件中使用 `shouldComponentUpdate`。
    * 在 Vue 中，虽然其响应式系统和编译优化已经做得很好，但仍然要注意 props 的稳定性，避免不必要的深度侦听等。
3.  **理解组件的生命周期和更新机制**：知道什么时候组件会更新，有助于写出更高效的代码。
4.  **合理组织组件结构**：将大的组件拆分成更小的、职责单一的组件，有助于隔离变化，减少更新范围。

## 八、总结

虚拟 DOM 和 Diff 算法是现代前端框架实现高性能UI更新的核心技术。它们通过在 JavaScript 层面模拟 DOM 结构，并通过高效的比较算法找出最小的变更集，从而减少了对昂贵的真实 DOM 操作。

* **React** 采用了一套行之有效的启发式 Diff 策略，并通过 JSX 提供了灵活的开发体验。其性能优化更多依赖于运行时的机制和开发者的手动优化。
* **Vue** 在 Diff 策略上与 React 有相似之处，Vue 2 的双端比较在列表 Diff 上有其特色。而 **Vue 3** 则通过强大的编译器，在编译阶段就对模板进行了深度分析和优化，引入了静态树提升、补丁标记和块级树等概念，使得运行时的 Diff 效率达到了新的高度，实现了更新性能与模板大小的解耦。

理解这些底层原理，不仅能帮助我们写出更高性能的代码，也能让我们在遇到复杂问题时有更清晰的排查思路。希望本文能为你揭开 Vue 和 React 中虚拟 DOM 与 Diff 算法的神秘面纱！