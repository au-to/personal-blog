---
title: Docker 全栈指南：从概念到多容器部署的完整实践
date: 2025/09/07
tags:
 - Docker
---

## 一、Docker 的基础：镜像与容器

理解 Docker 的第一步，是区分它的两个核心组件。

### 1. 镜像（Image） vs. 容器（Container）

| 概念 | 类比 | 关键特性 |
| :--- | :--- | :--- |
| **镜像 (Image)** | 烘焙蛋糕的**食谱**或**蓝图**。 | 只读、分层存储，包含应用运行所需的一切。 |
| **容器 (Container)** | 烘焙好的**蛋糕实例**。 | 镜像的运行实例，拥有一个可写层和独立的进程。 |

### 2. 镜像分层与数据持久化

* **分层存储 (Layering)**：镜像由多个只读层堆叠而成，这使得镜像可以高效地共享和复用，并节省磁盘空间。
* **容器的可写层**：容器运行时会创建一个可写层，所有运行时的数据变更都发生在这里。**注意：** 当容器被删除（`docker rm`）时，可写层的数据会**彻底丢失**（即数据是**临时性**的）。
* **数据卷 (Volumes)**：Docker 解决数据持久化的方案。它将数据存储在宿主机的**独立区域**，数据卷的生命周期与容器**分离**，即使容器被删除，数据依然保留。

---

## 二、命令行操作：Docker 的三板斧

以下是日常使用 Docker 必须掌握的命令和技巧。

| 类别 | 命令 | 描述 | 实用参数 |
| :--- | :--- | :--- | :--- |
| **运行** | `docker run` | 运行镜像并创建容器。 | **`-d`**：后台运行（Detached Mode）； **`-p Host:Container`**：端口映射。 |
| **查看** | `docker ps` | 查看容器状态。 | **`-a`**：查看所有容器（包括已退出）；**`--name`**：为容器命名。 |
| **日志** | `docker logs` | 查看容器的输出日志。 | **`-f`**：实时跟踪日志（Follow）。 |
| **清理** | `docker stop` | 平稳地停止正在运行的容器。 | **`docker stop [ID]`** |
| **清理** | `docker rm` | 删除已停止的容器。 | **`docker rm [ID]`** |
| **清理** | `docker rmi` | 删除本地镜像。 | **`docker rmi [ImageName]`** |
| **终极清理**| **`docker system prune`** | **一键清理**所有已停止容器、未使用的网络和悬挂镜像。 | **`-a --volumes`**：同时清理未使用的 Volumes（谨慎使用）。|

---

## 三、定制化：制作你的应用镜像 (Dockerfile)

如果想构建自己的应用环境，就需要编写一个 **`Dockerfile`**。

| 指令 | 作用描述 | 最佳实践 |
| :--- | :--- | :--- |
| **`FROM`** | 指定构建所需的基础镜像（如 `ubuntu:22.04`）。 | 始终放在第一行。 |
| **`RUN`** | 在镜像**构建时**执行命令（如安装依赖）。 | 将多个命令用 `&&` 连接成一个 `RUN`，以**最小化层数**，并**清理缓存**。 |
| **`COPY`** | 将宿主机文件/代码复制到镜像指定路径。 | `COPY [本地源路径] [镜像目标路径]` |
| **`CMD`** | 定义容器**启动时**执行的默认命令。 | 必须让主进程保持在 **前台 (FOREGROUND)** 运行，否则容器会立即退出。 |

**构建命令：** `docker build -t [你的用户名]/[名称]:[标签] .`

---

## 四、规模化：网络与容器编排

手动运行多个容器复杂且低效，Docker Compose 是解决多服务部署的最佳工具。

### 1. 容器网络通信

* **问题**：容器 IP 不稳定，无法直接用 IP 通信。
* **解决方案**：创建**自定义 Bridge 网络**。连接到同一网络的容器可以利用彼此的 **容器名称** 进行 **服务发现**。
* **命令流程**：
    1.  创建网络：`docker network create app-net`
    2.  连接容器：`docker run --network app-net --name web-container ...`

### 2. Docker Compose (多容器编排)

* **核心**：使用 **`docker-compose.yml`** 文件（YAML格式）来定义应用的所有服务、网络和 Volumes。
* **关键配置项**：`image`、`ports`、`networks`、`volumes`。

| YAML 配置项 | 对应 `docker run` 参数 |
| :--- | :--- |
| `image: nginx` | 镜像名称 |
| `ports: ['8080:80']` | `-p 8080:80` |
| `networks: [app-net]` | `--network app-net` |

**启动/停止命令：**
* 启动所有服务：`docker compose up -d`
* 停止并删除所有服务和网络：`docker compose down`

---

## 五、高级实践：安全与存储

### 1. 安全与隔离

Docker 的安全隔离主要依赖 Linux 内核的两个机制：

| 机制 | 作用 | 安全意义 |
| :--- | :--- | :--- |
| **Namespaces** | 隔离**可见性**（进程、网络、用户 ID）。 | 容器内的 **root 权限** 被映射为宿主机上的**非特权用户**，防止权限提升。 |
| **Cgroups** | 隔离**资源使用**（CPU、内存、I/O）。 | 防止单个失控容器耗尽所有资源，导致整个系统**拒绝服务 (DoS)**。 |

### 2. 高级存储类型

除了常用的 Volume，了解其他存储类型能优化你的开发和运维流程：

| 存储类型 | 数据位置 | 最佳用途 | 数据持久性 |
| :--- | :--- | :--- | :--- |
| **Volume** | 宿主机硬盘（Docker管理）| 生产环境**数据持久化**（数据库文件）。 | **持久** |
| **Bind Mount**| 宿主机上的**任意目录**。 | **本地开发**（实时同步代码）。 | **持久** |
| **tmpfs Mount**| 宿主机的 **RAM/内存**。 | 存储临时的高速缓存或**敏感数据**（避免写入磁盘）。 | **易失**（重启即丢失）|