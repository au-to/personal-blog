import{_ as e,c as o,b as n,a as p,d as a,e as l,r as c,o as i}from"./app-D4UOOi8i.js";const r={},u={style:{"text-align":"left"}},d={href:"https://www.example.com",target:"_blank",rel:"noopener noreferrer"};function g(k,s){const t=c("ExternalLinkIcon");return i(),o("div",null,[s[9]||(s[9]=n("h2",{id:"什么是跨域-为什么会产生跨域",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#什么是跨域-为什么会产生跨域"},[n("span",null,"什么是跨域？为什么会产生跨域？")])],-1)),s[10]||(s[10]=n("p",null,[n("strong",null,"跨域"),a("（Cross-Origin）指的是当一个"),n("strong",null,"源"),a("（Origin）的文档或脚本试图去加载或操作另一个"),n("strong",null,"源"),a("的资源时发生的情况。这里的“源”是由**协议（Protocol）、域名（Domain）和端口（Port）**三者共同决定的。只要这三者中有一个不同，就属于不同的源。")],-1)),s[11]||(s[11]=n("p",null,"例如：",-1)),n("table",null,[s[8]||(s[8]=n("thead",null,[n("tr",null,[n("th",{style:{"text-align":"left"}},"URL"),n("th",{style:{"text-align":"left"}},"协议"),n("th",{style:{"text-align":"left"}},"域名"),n("th",{style:{"text-align":"left"}},"端口"),n("th",{style:{"text-align":"left"}},[a("是否同源于 "),n("code",null,"http://example.com:8080/index.html")])])],-1)),n("tbody",null,[s[5]||(s[5]=n("tr",null,[n("td",{style:{"text-align":"left"}},[n("code",null,"http://example.com:8080/other.html")]),n("td",{style:{"text-align":"left"}},"http"),n("td",{style:{"text-align":"left"}},"example.com"),n("td",{style:{"text-align":"left"}},"8080"),n("td",{style:{"text-align":"left"}},"是")],-1)),s[6]||(s[6]=n("tr",null,[n("td",{style:{"text-align":"left"}},[n("code",null,"https://example.com:8080/index.html")]),n("td",{style:{"text-align":"left"}},"https"),n("td",{style:{"text-align":"left"}},"example.com"),n("td",{style:{"text-align":"left"}},"8080"),n("td",{style:{"text-align":"left"}},"否 (协议不同)")],-1)),n("tr",null,[s[1]||(s[1]=n("td",{style:{"text-align":"left"}},[n("code",null,"http://www.example.com:8080/index.html")],-1)),s[2]||(s[2]=n("td",{style:{"text-align":"left"}},"http",-1)),n("td",u,[n("a",d,[s[0]||(s[0]=a("www.example.com",-1)),l(t)])]),s[3]||(s[3]=n("td",{style:{"text-align":"left"}},"8080",-1)),s[4]||(s[4]=n("td",{style:{"text-align":"left"}},"否 (域名不同)",-1))]),s[7]||(s[7]=n("tr",null,[n("td",{style:{"text-align":"left"}},[n("code",null,"http://example.com:80/index.html")]),n("td",{style:{"text-align":"left"}},"http"),n("td",{style:{"text-align":"left"}},"example.com"),n("td",{style:{"text-align":"left"}},"80"),n("td",{style:{"text-align":"left"}},"否 (端口不同)")],-1))])]),s[12]||(s[12]=p(`<p><strong>产生跨域的根本原因是浏览器的同源策略（Same-Origin Policy, SOP）。</strong> 这是一个重要的安全策略，旨在保护用户的浏览器免受恶意网站的攻击。</p><p><strong>同源策略的主要限制包括：</strong></p><ol><li><strong>Cookie、LocalStorage 和 IndexDB 无法读取。</strong> 不同源的页面无法直接访问对方存储在浏览器中的数据。</li><li><strong>DOM 无法获得。</strong> 不同源的页面无法直接操作对方的 DOM 结构。</li><li><strong>AJAX 请求不能发送。</strong> 这是最常见的跨域问题。默认情况下，使用 <code>XMLHttpRequest</code> 或 Fetch API 发起的 HTTP 请求只能访问同源的资源。如果请求的目标是不同源的，浏览器会阻止该请求的响应被当前页面获取，尽管请求可能已经到达服务器。</li></ol><p><strong>为什么需要同源策略？</strong></p><p>想象一下，如果你在浏览器中打开了一个银行网站，然后又打开了一个恶意网站。如果没有同源策略，恶意网站的脚本就可以轻易地读取你在银行网站上的 Cookie，甚至模拟你的操作，从而窃取你的敏感信息或进行未授权的交易。同源策略就像一道防火墙，隔离了不同源之间的直接交互，大大增强了浏览器的安全性。</p><hr><h2 id="常见的跨域解决方案及原理" tabindex="-1"><a class="header-anchor" href="#常见的跨域解决方案及原理"><span>常见的跨域解决方案及原理</span></a></h2><p>虽然同源策略是必要的，但在实际开发中，我们经常需要在不同源之间进行合理的资源共享。以下是一些常见的跨域解决方案及其原理：</p><h3 id="_1-cors-cross-origin-resource-sharing-跨域资源共享-🛡️" tabindex="-1"><a class="header-anchor" href="#_1-cors-cross-origin-resource-sharing-跨域资源共享-🛡️"><span>1. CORS (Cross-Origin Resource Sharing) 跨域资源共享 🛡️</span></a></h3><p><strong>原理：</strong> CORS 是一种 W3C 标准，它允许服务器在响应头中添加一些特殊的 HTTP 头部字段，从而告诉浏览器，允许来自指定源的跨域请求。浏览器在收到响应后，会检查这些头部字段，如果符合条件，就允许 JavaScript 获取响应内容。</p><p><strong>核心 HTTP 头部字段：</strong></p><ul><li><strong><code>Access-Control-Allow-Origin</code></strong>: 这是最重要的头部。它指定了哪些源可以访问该资源。例如： <ul><li><code>Access-Control-Allow-Origin: *</code> (允许任何源访问，但通常不推荐用于需要凭证的请求)</li><li><code>Access-Control-Allow-Origin: http://example.com</code> (只允许来自 <code>http://example.com</code> 的请求)</li></ul></li><li><strong><code>Access-Control-Allow-Methods</code></strong>: 指定了允许的 HTTP 请求方法，例如 <code>GET, POST, PUT, DELETE</code>。</li><li><strong><code>Access-Control-Allow-Headers</code></strong>: 指定了允许的自定义请求头部。</li><li><strong><code>Access-Control-Allow-Credentials</code></strong>: 一个布尔值，表示是否允许发送 Cookie。如果设置为 <code>true</code>，那么 <code>Access-Control-Allow-Origin</code> 就不能是 <code>*</code>，必须指定明确的源。</li><li><strong><code>Access-Control-Max-Age</code></strong>: 指定了预检请求（Preflight Request）结果的有效期（单位：秒）。</li></ul><p><strong>请求类型：</strong></p><p>CORS 请求分为两类：</p><ul><li><p><strong>简单请求 (Simple Requests):</strong> 同时满足以下所有条件的请求：</p><ul><li>请求方法是 <code>GET</code>, <code>HEAD</code>, <code>POST</code> 之一。</li><li>HTTP 头部信息不超出以下几种字段：<code>Accept</code>, <code>Accept-Language</code>, <code>Content-Language</code>, <code>Last-Event-ID</code>, <code>Content-Type</code> (只限于 <code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code>, <code>text/plain</code> 三种)。</li><li>请求中没有自定义的 HTTP 头部。 对于简单请求，浏览器会直接发送请求，并在响应头中查找 <code>Access-Control-Allow-Origin</code> 等字段。</li></ul></li><li><p><strong>非简单请求 (Preflighted Requests):</strong> 不满足简单请求条件的请求，例如 <code>PUT</code>, <code>DELETE</code> 方法，或者 <code>Content-Type</code> 为 <code>application/json</code> 的请求，或者包含自定义头部的请求。 对于非简单请求，浏览器会先发送一个 <strong>预检请求 (Preflight Request)</strong>。这是一个 <code>OPTIONS</code> 方法的请求，用于询问服务器当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 方法和头部字段。</p><ul><li>如果预检请求成功（服务器返回了允许的 CORS 头部），浏览器才会发送实际的请求。</li><li>如果预检请求失败，浏览器会报错，实际请求不会发送。</li></ul></li></ul><p><strong>优点：</strong></p><ul><li>W3C 标准，主流浏览器都支持。</li><li>功能强大，支持各种 HTTP 方法和自定义头部。</li><li>相对安全，由服务器控制权限。</li></ul><p><strong>缺点：</strong></p><ul><li>需要服务器端进行配置。</li><li>对于非简单请求，会多一次预检请求，增加了一些开销（但可以通过 <code>Access-Control-Max-Age</code> 缓存）。</li></ul><h3 id="_2-jsonp-json-with-padding-📜" tabindex="-1"><a class="header-anchor" href="#_2-jsonp-json-with-padding-📜"><span>2. JSONP (JSON with Padding) 📜</span></a></h3><p><strong>原理：</strong> JSONP 利用了 HTML 中 <code>&lt;script&gt;</code> 标签的 <code>src</code> 属性不受同源策略限制的特点。</p><p>具体步骤如下：</p><ol><li><strong>客户端：</strong><ul><li>动态创建一个 <code>&lt;script&gt;</code> 标签。</li><li>将其 <code>src</code> 属性指向目标服务器的 URL，并在 URL 参数中指定一个回调函数名（例如 <code>callback=handleResponse</code>）。</li><li>将这个 <code>&lt;script&gt;</code> 标签插入到 DOM 中。</li></ul></li><li><strong>服务器端：</strong><ul><li>接收到请求后，获取回调函数名。</li><li>将要返回的 JSON 数据包裹在这个回调函数中，形成一个 JavaScript 函数调用的字符串，例如 <code>handleResponse({&quot;data&quot;: &quot;some data&quot;})</code>。</li><li>将这个字符串作为响应体返回给客户端，<code>Content-Type</code>通常是 <code>application/javascript</code>。</li></ul></li><li><strong>客户端：</strong><ul><li>当 <code>&lt;script&gt;</code> 标签加载并执行服务器返回的脚本时，实际上就是在调用预先定义好的回调函数 <code>handleResponse</code>，并将 JSON 数据作为参数传入。</li></ul></li></ol><p><strong>示例：</strong></p><p>客户端代码：</p><div class="language-html line-numbers-mode" data-highlighter="prismjs" data-ext="html" data-title="html"><pre><code><span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"></span>
<span class="line">  <span class="token keyword">function</span> <span class="token function">handleResponse</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Received data:&#39;</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://api.otherserver.com/data?callback=handleResponse<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>服务器端 (Node.js 示例):</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token comment">// http://api.otherserver.com/data</span></span>
<span class="line"><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;http&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">const</span> url <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;url&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">const</span> query <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>url<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span>query<span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">const</span> callbackName <span class="token operator">=</span> query<span class="token punctuation">.</span>callback<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>callbackName<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">const</span> jsonData <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">message</span><span class="token operator">:</span> <span class="token string">&quot;Hello from another server!&quot;</span><span class="token punctuation">,</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">42</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">const</span> responseString <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>callbackName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>jsonData<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">;</span></span>
<span class="line">    res<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token string-property property">&#39;Content-Type&#39;</span><span class="token operator">:</span> <span class="token string">&#39;application/javascript&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>responseString<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">    res<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">&#39;Callback function name required.&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8001</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>优点：</strong></p><ul><li>兼容性好，支持老旧浏览器。</li><li>简单易用。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>只支持 <code>GET</code> 请求。</strong> 因为 <code>&lt;script&gt;</code> 标签的 <code>src</code> 只能发起 <code>GET</code> 请求。</li><li><strong>安全性问题：</strong> 如果请求的服务器不可信，它返回的脚本可能包含恶意代码，在客户端执行。</li><li><strong>难以进行错误处理：</strong> <code>&lt;script&gt;</code> 标签的加载失败不容易捕获和处理（例如网络错误或服务器错误）。</li><li><strong>需要服务器端配合改造接口。</strong></li></ul><h3 id="_3-代理服务器-proxy-server-posrednik" tabindex="-1"><a class="header-anchor" href="#_3-代理服务器-proxy-server-posrednik"><span>3. 代理服务器 (Proxy Server) pośrednik</span></a></h3><p><strong>原理：</strong> 在客户端和目标服务器之间架设一个代理服务器。客户端向代理服务器发起请求（此时是同源请求），代理服务器再将请求转发给目标服务器。目标服务器将响应返回给代理服务器，代理服务器再将响应返回给客户端。</p><p>由于客户端和代理服务器之间是同源的，或者代理服务器可以配置 CORS 允许客户端访问，从而绕过了浏览器的同源策略限制。</p><p><strong>流程：</strong></p><ol><li><strong>客户端</strong> (<code>http://client.com</code>) 发送请求到 <strong>代理服务器</strong> (<code>http://client.com/proxy</code> 或 <code>http://proxy.client.com</code>)。</li><li><strong>代理服务器</strong> 接收到请求后，将请求转发到 <strong>目标服务器</strong> (<code>http://api.otherserver.com</code>)。</li><li><strong>目标服务器</strong> 处理请求并将响应返回给 <strong>代理服务器</strong>。</li><li><strong>代理服务器</strong> 将响应再返回给 <strong>客户端</strong>。</li></ol><p><strong>实现方式：</strong></p><ul><li><strong>Nginx 反向代理：</strong> 配置 Nginx 将特定路径的请求转发到目标服务器。</li><li><strong>Node.js 中间件：</strong> 例如使用 <code>http-proxy-middleware</code> 等库。</li><li><strong>后端语言实现：</strong> 例如 Java, Python, PHP 等都可以编写代理逻辑。</li></ul><p><strong>优点：</strong></p><ul><li>可以解决各种跨域问题，不限于 <code>GET</code> 请求。</li><li>不需要修改目标服务器的代码。</li><li>可以在代理层进行一些额外的处理，如缓存、权限控制等。</li></ul><p><strong>缺点：</strong></p><ul><li>需要额外部署和维护一个代理服务器。</li><li>增加了请求的链路，可能会有轻微的性能影响。</li></ul><h3 id="_4-document-domain-针对主域名相同-子域名不同的情况-🏡" tabindex="-1"><a class="header-anchor" href="#_4-document-domain-针对主域名相同-子域名不同的情况-🏡"><span>4. <code>document.domain</code> (针对主域名相同，子域名不同的情况) 🏡</span></a></h3><p><strong>原理：</strong> 如果两个页面具有相同的主域名，但子域名不同（例如 <code>a.example.com</code> 和 <code>b.example.com</code>），可以通过将两个页面的 <code>document.domain</code> 都设置为它们共同的主域名（例如 <code>example.com</code>），来实现它们之间的同源。</p><p><strong>限制：</strong></p><ul><li><strong>仅适用于主域名相同的情况。</strong></li><li><strong>只能将 <code>document.domain</code> 设置为当前域名或其父级域名，不能设置为任意值。</strong></li><li><strong>协议和端口也必须一致。</strong></li></ul><p><strong>示例：</strong></p><p>页面 A (<code>http://a.example.com/pageA.html</code>):</p><div class="language-html line-numbers-mode" data-highlighter="prismjs" data-ext="html" data-title="html"><pre><code><span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"></span>
<span class="line">  document<span class="token punctuation">.</span>domain <span class="token operator">=</span> <span class="token string">&#39;example.com&#39;</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token comment">// 现在可以访问 iframe B 的内容了</span></span>
<span class="line">  <span class="token keyword">const</span> iframeB <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&#39;iframeB&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  iframeB<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>iframeB<span class="token punctuation">.</span>contentWindow<span class="token punctuation">.</span>someVariable<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>iframeB<span class="token punctuation">&quot;</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://b.example.com/pageB.html<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>页面 B (<code>http://b.example.com/pageB.html</code>):</p><div class="language-html line-numbers-mode" data-highlighter="prismjs" data-ext="html" data-title="html"><pre><code><span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"></span>
<span class="line">  document<span class="token punctuation">.</span>domain <span class="token operator">=</span> <span class="token string">&#39;example.com&#39;</span><span class="token punctuation">;</span></span>
<span class="line">  window<span class="token punctuation">.</span>someVariable <span class="token operator">=</span> <span class="token string">&#39;Hello from Page B!&#39;</span><span class="token punctuation">;</span></span>
<span class="line"></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>优点：</strong></p><ul><li>简单易用，适用于特定的子域名跨域场景。</li></ul><p><strong>缺点：</strong></p><ul><li>限制较多，不适用于所有跨域场景。</li><li>安全性方面，如果一个子域名被攻破，可能会影响到其他设置了相同 <code>document.domain</code> 的子域名。</li></ul><h3 id="_5-window-postmessage-用于窗口间通信-✉️" tabindex="-1"><a class="header-anchor" href="#_5-window-postmessage-用于窗口间通信-✉️"><span>5. <code>window.postMessage</code> (用于窗口间通信) ✉️</span></a></h3><p><strong>原理：</strong> <code>window.postMessage()</code> 方法允许来自不同源的窗口（例如主页面和 <code>iframe</code>，或者通过 <code>window.open</code> 打开的新窗口）之间安全地传递消息。</p><p><strong>发送消息：</strong></p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token comment">// otherWindow 是目标窗口的引用 (例如 iframe.contentWindow)</span></span>
<span class="line"><span class="token comment">// message 是要发送的数据 (可以是任何可以被结构化克隆算法处理的数据)</span></span>
<span class="line"><span class="token comment">// targetOrigin 是目标窗口的源，用于安全校验，可以是 &#39;*&#39; (不推荐) 或具体的源</span></span>
<span class="line">otherWindow<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> targetOrigin<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>接收消息：</strong></p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line">window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;message&#39;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// 安全校验：检查消息来源是否可信</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>origin <span class="token operator">!==</span> <span class="token string">&#39;http://expected-sender.com&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">  <span class="token comment">// 处理接收到的数据</span></span>
<span class="line">  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Received message:&#39;</span><span class="token punctuation">,</span> event<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">  <span class="token comment">// 可以选择性地向来源窗口回复消息</span></span>
<span class="line">  event<span class="token punctuation">.</span>source<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token string">&#39;Message received!&#39;</span><span class="token punctuation">,</span> event<span class="token punctuation">.</span>origin<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>优点：</strong></p><ul><li>安全，可以指定消息接收方的源。</li><li>功能强大，可以传递复杂的数据结构。</li><li>适用于窗口之间（包括 <code>iframe</code>）的跨域通信。</li></ul><p><strong>缺点：</strong></p><ul><li>主要用于窗口间的消息传递，不直接解决 AJAX 请求的跨域问题（但可以结合使用，例如 <code>iframe</code> 内发起 AJAX，然后通过 <code>postMessage</code> 将结果传回主页面）。</li><li>需要双方都实现消息的发送和接收逻辑。</li></ul><hr><p><strong>总结一下选择哪种方案：</strong></p><ul><li><strong>首选 CORS：</strong> 这是最标准、最通用的解决方案，尤其是对于 API 接口的跨域。</li><li><strong>JSONP：</strong> 仅在需要兼容非常古老的浏览器且只涉及 <code>GET</code> 请求时考虑，注意安全风险。</li><li><strong>代理服务器：</strong> 当无法修改目标服务器，或者需要在中间层做更多控制时是个好选择。</li><li><strong><code>document.domain</code>：</strong> 仅限于主域名相同、子域名不同的特定场景。</li><li><strong><code>window.postMessage</code>：</strong> 主要用于解决不同窗口或 <code>iframe</code> 之间的安全通信问题。</li></ul>`,69))])}const v=e(r,[["render",g]]),h=JSON.parse('{"path":"/blogs/liulanqi/kuayudeyuanyinhejiejuefangan.html","title":"聊聊跨域的原因及常见的解决方案","lang":"en-US","frontmatter":{"title":"聊聊跨域的原因及常见的解决方案","date":"2025/04/08","tags":["浏览器"],"categories":["浏览器"]},"headers":[{"level":2,"title":"什么是跨域？为什么会产生跨域？","slug":"什么是跨域-为什么会产生跨域","link":"#什么是跨域-为什么会产生跨域","children":[]},{"level":2,"title":"常见的跨域解决方案及原理","slug":"常见的跨域解决方案及原理","link":"#常见的跨域解决方案及原理","children":[{"level":3,"title":"1. CORS (Cross-Origin Resource Sharing) 跨域资源共享 🛡️","slug":"_1-cors-cross-origin-resource-sharing-跨域资源共享-🛡️","link":"#_1-cors-cross-origin-resource-sharing-跨域资源共享-🛡️","children":[]},{"level":3,"title":"2. JSONP (JSON with Padding) 📜","slug":"_2-jsonp-json-with-padding-📜","link":"#_2-jsonp-json-with-padding-📜","children":[]},{"level":3,"title":"3. 代理服务器 (Proxy Server)  pośrednik","slug":"_3-代理服务器-proxy-server-posrednik","link":"#_3-代理服务器-proxy-server-posrednik","children":[]},{"level":3,"title":"4. document.domain (针对主域名相同，子域名不同的情况) 🏡","slug":"_4-document-domain-针对主域名相同-子域名不同的情况-🏡","link":"#_4-document-domain-针对主域名相同-子域名不同的情况-🏡","children":[]},{"level":3,"title":"5. window.postMessage (用于窗口间通信) ✉️","slug":"_5-window-postmessage-用于窗口间通信-✉️","link":"#_5-window-postmessage-用于窗口间通信-✉️","children":[]}]}],"git":{"createdTime":1748408580000,"updatedTime":1748408580000,"contributors":[{"name":"Ryan","email":"2996442165@qq.com","commits":1}]},"filePathRelative":"blogs/浏览器/跨域的原因和解决方案.md"}');export{v as comp,h as data};
