import{_ as e,c as l,a as o,o as n}from"./app-_qvWuZqY.js";const r={};function d(s,t){return n(),l("div",null,[...t[0]||(t[0]=[o('<h2 id="一、docker-的基础-镜像与容器" tabindex="-1"><a class="header-anchor" href="#一、docker-的基础-镜像与容器"><span>一、Docker 的基础：镜像与容器</span></a></h2><p>理解 Docker 的第一步，是区分它的两个核心组件。</p><h3 id="_1-镜像-image-vs-容器-container" tabindex="-1"><a class="header-anchor" href="#_1-镜像-image-vs-容器-container"><span>1. 镜像（Image） vs. 容器（Container）</span></a></h3><table><thead><tr><th style="text-align:left;">概念</th><th style="text-align:left;">类比</th><th style="text-align:left;">关键特性</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>镜像 (Image)</strong></td><td style="text-align:left;">烘焙蛋糕的<strong>食谱</strong>或<strong>蓝图</strong>。</td><td style="text-align:left;">只读、分层存储，包含应用运行所需的一切。</td></tr><tr><td style="text-align:left;"><strong>容器 (Container)</strong></td><td style="text-align:left;">烘焙好的<strong>蛋糕实例</strong>。</td><td style="text-align:left;">镜像的运行实例，拥有一个可写层和独立的进程。</td></tr></tbody></table><h3 id="_2-镜像分层与数据持久化" tabindex="-1"><a class="header-anchor" href="#_2-镜像分层与数据持久化"><span>2. 镜像分层与数据持久化</span></a></h3><ul><li><strong>分层存储 (Layering)</strong>：镜像由多个只读层堆叠而成，这使得镜像可以高效地共享和复用，并节省磁盘空间。</li><li><strong>容器的可写层</strong>：容器运行时会创建一个可写层，所有运行时的数据变更都发生在这里。<strong>注意：</strong> 当容器被删除（<code>docker rm</code>）时，可写层的数据会<strong>彻底丢失</strong>（即数据是<strong>临时性</strong>的）。</li><li><strong>数据卷 (Volumes)</strong>：Docker 解决数据持久化的方案。它将数据存储在宿主机的<strong>独立区域</strong>，数据卷的生命周期与容器<strong>分离</strong>，即使容器被删除，数据依然保留。</li></ul><hr><h2 id="二、命令行操作-docker-的三板斧" tabindex="-1"><a class="header-anchor" href="#二、命令行操作-docker-的三板斧"><span>二、命令行操作：Docker 的三板斧</span></a></h2><p>以下是日常使用 Docker 必须掌握的命令和技巧。</p><table><thead><tr><th style="text-align:left;">类别</th><th style="text-align:left;">命令</th><th style="text-align:left;">描述</th><th style="text-align:left;">实用参数</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>运行</strong></td><td style="text-align:left;"><code>docker run</code></td><td style="text-align:left;">运行镜像并创建容器。</td><td style="text-align:left;"><strong><code>-d</code></strong>：后台运行（Detached Mode）； <strong><code>-p Host:Container</code></strong>：端口映射。</td></tr><tr><td style="text-align:left;"><strong>查看</strong></td><td style="text-align:left;"><code>docker ps</code></td><td style="text-align:left;">查看容器状态。</td><td style="text-align:left;"><strong><code>-a</code></strong>：查看所有容器（包括已退出）；<strong><code>--name</code></strong>：为容器命名。</td></tr><tr><td style="text-align:left;"><strong>日志</strong></td><td style="text-align:left;"><code>docker logs</code></td><td style="text-align:left;">查看容器的输出日志。</td><td style="text-align:left;"><strong><code>-f</code></strong>：实时跟踪日志（Follow）。</td></tr><tr><td style="text-align:left;"><strong>清理</strong></td><td style="text-align:left;"><code>docker stop</code></td><td style="text-align:left;">平稳地停止正在运行的容器。</td><td style="text-align:left;"><strong><code>docker stop [ID]</code></strong></td></tr><tr><td style="text-align:left;"><strong>清理</strong></td><td style="text-align:left;"><code>docker rm</code></td><td style="text-align:left;">删除已停止的容器。</td><td style="text-align:left;"><strong><code>docker rm [ID]</code></strong></td></tr><tr><td style="text-align:left;"><strong>清理</strong></td><td style="text-align:left;"><code>docker rmi</code></td><td style="text-align:left;">删除本地镜像。</td><td style="text-align:left;"><strong><code>docker rmi [ImageName]</code></strong></td></tr><tr><td style="text-align:left;"><strong>终极清理</strong></td><td style="text-align:left;"><strong><code>docker system prune</code></strong></td><td style="text-align:left;"><strong>一键清理</strong>所有已停止容器、未使用的网络和悬挂镜像。</td><td style="text-align:left;"><strong><code>-a --volumes</code></strong>：同时清理未使用的 Volumes（谨慎使用）。</td></tr></tbody></table><hr><h2 id="三、定制化-制作你的应用镜像-dockerfile" tabindex="-1"><a class="header-anchor" href="#三、定制化-制作你的应用镜像-dockerfile"><span>三、定制化：制作你的应用镜像 (Dockerfile)</span></a></h2><p>如果想构建自己的应用环境，就需要编写一个 <strong><code>Dockerfile</code></strong>。</p><table><thead><tr><th style="text-align:left;">指令</th><th style="text-align:left;">作用描述</th><th style="text-align:left;">最佳实践</th></tr></thead><tbody><tr><td style="text-align:left;"><strong><code>FROM</code></strong></td><td style="text-align:left;">指定构建所需的基础镜像（如 <code>ubuntu:22.04</code>）。</td><td style="text-align:left;">始终放在第一行。</td></tr><tr><td style="text-align:left;"><strong><code>RUN</code></strong></td><td style="text-align:left;">在镜像<strong>构建时</strong>执行命令（如安装依赖）。</td><td style="text-align:left;">将多个命令用 <code>&amp;&amp;</code> 连接成一个 <code>RUN</code>，以<strong>最小化层数</strong>，并<strong>清理缓存</strong>。</td></tr><tr><td style="text-align:left;"><strong><code>COPY</code></strong></td><td style="text-align:left;">将宿主机文件/代码复制到镜像指定路径。</td><td style="text-align:left;"><code>COPY [本地源路径] [镜像目标路径]</code></td></tr><tr><td style="text-align:left;"><strong><code>CMD</code></strong></td><td style="text-align:left;">定义容器<strong>启动时</strong>执行的默认命令。</td><td style="text-align:left;">必须让主进程保持在 <strong>前台 (FOREGROUND)</strong> 运行，否则容器会立即退出。</td></tr></tbody></table><p><strong>构建命令：</strong> <code>docker build -t [你的用户名]/[名称]:[标签] .</code></p><hr><h2 id="四、规模化-网络与容器编排" tabindex="-1"><a class="header-anchor" href="#四、规模化-网络与容器编排"><span>四、规模化：网络与容器编排</span></a></h2><p>手动运行多个容器复杂且低效，Docker Compose 是解决多服务部署的最佳工具。</p><h3 id="_1-容器网络通信" tabindex="-1"><a class="header-anchor" href="#_1-容器网络通信"><span>1. 容器网络通信</span></a></h3><ul><li><strong>问题</strong>：容器 IP 不稳定，无法直接用 IP 通信。</li><li><strong>解决方案</strong>：创建<strong>自定义 Bridge 网络</strong>。连接到同一网络的容器可以利用彼此的 <strong>容器名称</strong> 进行 <strong>服务发现</strong>。</li><li><strong>命令流程</strong>： <ol><li>创建网络：<code>docker network create app-net</code></li><li>连接容器：<code>docker run --network app-net --name web-container ...</code></li></ol></li></ul><h3 id="_2-docker-compose-多容器编排" tabindex="-1"><a class="header-anchor" href="#_2-docker-compose-多容器编排"><span>2. Docker Compose (多容器编排)</span></a></h3><ul><li><strong>核心</strong>：使用 <strong><code>docker-compose.yml</code></strong> 文件（YAML格式）来定义应用的所有服务、网络和 Volumes。</li><li><strong>关键配置项</strong>：<code>image</code>、<code>ports</code>、<code>networks</code>、<code>volumes</code>。</li></ul><table><thead><tr><th style="text-align:left;">YAML 配置项</th><th style="text-align:left;">对应 <code>docker run</code> 参数</th></tr></thead><tbody><tr><td style="text-align:left;"><code>image: nginx</code></td><td style="text-align:left;">镜像名称</td></tr><tr><td style="text-align:left;"><code>ports: [&#39;8080:80&#39;]</code></td><td style="text-align:left;"><code>-p 8080:80</code></td></tr><tr><td style="text-align:left;"><code>networks: [app-net]</code></td><td style="text-align:left;"><code>--network app-net</code></td></tr></tbody></table><p><strong>启动/停止命令：</strong></p><ul><li>启动所有服务：<code>docker compose up -d</code></li><li>停止并删除所有服务和网络：<code>docker compose down</code></li></ul><hr><h2 id="五、高级实践-安全与存储" tabindex="-1"><a class="header-anchor" href="#五、高级实践-安全与存储"><span>五、高级实践：安全与存储</span></a></h2><h3 id="_1-安全与隔离" tabindex="-1"><a class="header-anchor" href="#_1-安全与隔离"><span>1. 安全与隔离</span></a></h3><p>Docker 的安全隔离主要依赖 Linux 内核的两个机制：</p><table><thead><tr><th style="text-align:left;">机制</th><th style="text-align:left;">作用</th><th style="text-align:left;">安全意义</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>Namespaces</strong></td><td style="text-align:left;">隔离<strong>可见性</strong>（进程、网络、用户 ID）。</td><td style="text-align:left;">容器内的 <strong>root 权限</strong> 被映射为宿主机上的<strong>非特权用户</strong>，防止权限提升。</td></tr><tr><td style="text-align:left;"><strong>Cgroups</strong></td><td style="text-align:left;">隔离<strong>资源使用</strong>（CPU、内存、I/O）。</td><td style="text-align:left;">防止单个失控容器耗尽所有资源，导致整个系统<strong>拒绝服务 (DoS)</strong>。</td></tr></tbody></table><h3 id="_2-高级存储类型" tabindex="-1"><a class="header-anchor" href="#_2-高级存储类型"><span>2. 高级存储类型</span></a></h3><p>除了常用的 Volume，了解其他存储类型能优化你的开发和运维流程：</p><table><thead><tr><th style="text-align:left;">存储类型</th><th style="text-align:left;">数据位置</th><th style="text-align:left;">最佳用途</th><th style="text-align:left;">数据持久性</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>Volume</strong></td><td style="text-align:left;">宿主机硬盘（Docker管理）</td><td style="text-align:left;">生产环境<strong>数据持久化</strong>（数据库文件）。</td><td style="text-align:left;"><strong>持久</strong></td></tr><tr><td style="text-align:left;"><strong>Bind Mount</strong></td><td style="text-align:left;">宿主机上的<strong>任意目录</strong>。</td><td style="text-align:left;"><strong>本地开发</strong>（实时同步代码）。</td><td style="text-align:left;"><strong>持久</strong></td></tr><tr><td style="text-align:left;"><strong>tmpfs Mount</strong></td><td style="text-align:left;">宿主机的 <strong>RAM/内存</strong>。</td><td style="text-align:left;">存储临时的高速缓存或<strong>敏感数据</strong>（避免写入磁盘）。</td><td style="text-align:left;"><strong>易失</strong>（重启即丢失）</td></tr></tbody></table>',33)])])}const g=e(r,[["render",d]]),i=JSON.parse('{"path":"/blogs/houduan/Dockerquanzhanzhinan.html","title":"Docker 全栈指南：从概念到多容器部署的完整实践","lang":"en-US","frontmatter":{"title":"Docker 全栈指南：从概念到多容器部署的完整实践","date":"2025/09/07","tags":["Docker"],"categories":["后端"]},"headers":[{"level":2,"title":"一、Docker 的基础：镜像与容器","slug":"一、docker-的基础-镜像与容器","link":"#一、docker-的基础-镜像与容器","children":[{"level":3,"title":"1. 镜像（Image） vs. 容器（Container）","slug":"_1-镜像-image-vs-容器-container","link":"#_1-镜像-image-vs-容器-container","children":[]},{"level":3,"title":"2. 镜像分层与数据持久化","slug":"_2-镜像分层与数据持久化","link":"#_2-镜像分层与数据持久化","children":[]}]},{"level":2,"title":"二、命令行操作：Docker 的三板斧","slug":"二、命令行操作-docker-的三板斧","link":"#二、命令行操作-docker-的三板斧","children":[]},{"level":2,"title":"三、定制化：制作你的应用镜像 (Dockerfile)","slug":"三、定制化-制作你的应用镜像-dockerfile","link":"#三、定制化-制作你的应用镜像-dockerfile","children":[]},{"level":2,"title":"四、规模化：网络与容器编排","slug":"四、规模化-网络与容器编排","link":"#四、规模化-网络与容器编排","children":[{"level":3,"title":"1. 容器网络通信","slug":"_1-容器网络通信","link":"#_1-容器网络通信","children":[]},{"level":3,"title":"2. Docker Compose (多容器编排)","slug":"_2-docker-compose-多容器编排","link":"#_2-docker-compose-多容器编排","children":[]}]},{"level":2,"title":"五、高级实践：安全与存储","slug":"五、高级实践-安全与存储","link":"#五、高级实践-安全与存储","children":[{"level":3,"title":"1. 安全与隔离","slug":"_1-安全与隔离","link":"#_1-安全与隔离","children":[]},{"level":3,"title":"2. 高级存储类型","slug":"_2-高级存储类型","link":"#_2-高级存储类型","children":[]}]}],"git":{"createdTime":1759738748000,"updatedTime":1759738748000,"contributors":[{"name":"zhaohubiao","email":"zhaohubiao@pharmolix.com","commits":1}]},"filePathRelative":"blogs/后端/Docker全栈指南.md"}');export{g as comp,i as data};
